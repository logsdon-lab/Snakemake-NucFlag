LOGS_DIR = config.get("logs_dir", "logs/nucflag")
BMKS_DIR = config.get("benchmarks_dir", "benchmarks/nucflag")
ALIGNER = config.get("aligner", "minimap2")
ALIGNER_OPTS = config.get("aligner_opts", "-y -a --eqx --cs -x lr:hqae -I8g")
SAMPLE_INFO = {sm["name"]: sm for sm in config["samples"]}


wildcard_constraints:
    sm="|".join(SAMPLE_INFO.keys()),


module Align:
    snakefile:
        "rules/Snakemake-Aligner/workflow/Snakefile"
    config:
        {
            **config,
            "aligner": ALIGNER,
            "aligner_opts": ALIGNER_OPTS,
            "logs_dir": LOGS_DIR,
            "benchmarks_dir": BMKS_DIR,
        }


use rule * from Align as aln_*


rule check_asm_nucflag:
    input:
        bam=ancient(rules.aln_merge_read_asm_alignments.output.alignment),
        fa=ancient(rules.aln_merge_asm_files.output.asm),
        fai=ancient(rules.aln_merge_asm_files.output.idx),
        # Optional arguments.
        regions=lambda wc: SAMPLE_INFO[str(wc.sm)].get("region_bed", []),
        config=lambda wc: SAMPLE_INFO[str(wc.sm)].get("config", []),
        ignore_regions=lambda wc: SAMPLE_INFO[str(wc.sm)].get("ignore_bed", []),
        overlay_regions=lambda wc: SAMPLE_INFO[str(wc.sm)].get("overlay_beds", []),
    output:
        plot_dir=directory(os.path.join(config["output_dir"], "{sm}")),
        pileup_dir=(
            directory(os.path.join(config["output_dir"], "{sm}_pileup"))
            if config.get("output_pileup")
            else []
        ),
        misassemblies=os.path.join(
            config["output_dir"],
            "{sm}_misassemblies.bed",
        ),
        status=os.path.join(
            config["output_dir"],
            "{sm}_status.bed",
        ),
    params:
        preset=lambda wc: (
            f"-x {SAMPLE_INFO[str(wc.sm)]['preset']}"
            if SAMPLE_INFO[str(wc.sm)].get("preset")
            else ""
        ),
        regions=lambda wc, input: f"-b {input.regions}" if input.regions else "",
        config=lambda wc, input: f"-c {input.config}" if input.config else "",
        ignore_regions=lambda wc, input: (
            f"--ignore_regions {input.ignore_regions}" if input.ignore_regions else ""
        ),
        overlay_regions=lambda wc, input: (
            f"--overlay_regions {' '.join(input.overlay_regions)}"
            if input.overlay_regions
            else ""
        ),
        output_pileup=lambda wc, output: (
            f"--output_pileup_dir {output.pileup_dir}"
            if config.get("output_coverage")
            else ""
        ),
    threads: config["threads_nucflag"]
    conda:
        "env/nucflag.yaml"
    resources:
        processes=config["processes_nucflag"],
        mem=config["mem_nucflag"],
    log:
        os.path.join(LOGS_DIR, "run_nucflag_{sm}.log"),
    benchmark:
        os.path.join(BMKS_DIR, "run_nucflag_{sm}.tsv")
    shell:
        """
        nucflag \
        -i {input.bam} \
        -f {input.fa} \
        -d {output.plot_dir} \
        -o {output.misassemblies} \
        -s {output.status} \
        -t {threads} \
        -p {resources.processes} \
        {params.preset} \
        {params.config} \
        {params.regions} \
        {params.ignore_regions} \
        {params.overlay_regions} \
        {params.output_pileup} &> {log}
        """


rule nucflag:
    input:
        expand(rules.check_asm_nucflag.output, sm=SAMPLE_INFO.keys()),
    default_target: True
